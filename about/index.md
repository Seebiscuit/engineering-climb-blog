---
layout: layouts/post.njk
title: About Me
templateClass: tmpl-post
eleventyNavigation:
  key: About Me
  order: 3
featuredImage: ./img/posts/gary_coffe_monitors.jpg
featuredImageAlt: Way too happy, or way too much caffeine?
featuredImageSize: ''
---

I never meant to be a coder. 

Coding, happened to me. Like so many of us in the field, I took a sip from the cup of automation and I was hooked. While I've been toying with computers as far back as I can remember, for me programming really started with shell scripting on Linux (hashbang for life!). At the time, I had to benchmark bandwidth performance for a shared computing node we were maintaining the Physics program I was in. For most High Energy Physics grad students, taming the collocation was a rite of passage. I stepped into the passage, and never really left.

My early experience, I've come to learn, shares many parallels with other self-taught Software Engineers (and possibly many Comp. Sci. graduates). There's the freshness of discovery and the rush of creative power. There's the sweat and blood sunk into long debugging sessions. There's the frequent mind expansion, the fog and the dawning of understanding. Early programming is the time when almost anything is possible just beyond the horizon.

Tinkering can last for years. From what I've seen, the maturing of the Software Engineer takes time and pressure. From the tinkerer, the hacker, the duct tap master, eventually emerges, the Software Engineer. And what exactly is this evolved specimen? How is the engineer different from the tinkerer? 

A working description I find handy comes from Fred Brooks (who wrote one of the seminal books on the philosophy&mdash;and practice&mdash;of software engineering, <a href="https://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/" target="_blank">_The Mythical Man-Month_</a>. Brooks notes that many great ideas are born from two guys in a garage. The question begging to be asked is, if these two guys are such a hit, why don't we re-organize all of our engineering teams into two-people groups and stick them in a damp, cramped space? 

Because ideas that come from the garage, while they may be ground-breaking, are missing the many layers of sophistication that are required to make them into commercial applications. Brooks estimates that the cost of making commercial grade-software, software that is intuitive, maintainable, well-documented, modular, etc, etc, is about 9 times greater than the cost of making garage-ware. In my opinion, the 9-fold multiplier is generous.

Engineering is the discipline of applying science to real life problems. As software engineers we are concerned with the set of software product best-practices to solve a business problem. That's pretty broad, but in practice software engineers can be responsible for architecture, estimation, construction, and provisioning. 

The first reaction many folks may have when they read that last sentence is that, outside construction, which is the literal act of coding, most of us may not really have much training. And for the engineers amongst us that sort of stumbled into software engineering, that's largely true. Architecting, estimating and provisioning are often arts that come later in our careers. 

My interest in laying down the characters you'll see in this site is to share and expose those topics that take us from the realm of coding to the field of engineering. Some of the topics may seem foreign, but the advice folded into these posts should sound reasonable and compelling. If I do my job right, you'll be inspired to pore deeper into the art of crafting reliable software that's delightful to create and use.

I never meant to be a code, but I'm really serious about software engineering.

